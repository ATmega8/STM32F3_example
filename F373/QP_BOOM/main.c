/*****************************************************************************
* Model: model.qm
* File:  Code/main.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*L. 2014*/
/* @(/2/0) .................................................................*/
#include "main.h"

#define BSP_TICKS_PER_SEC 10
#define INIT_DEFUSE 127
#define INIT_TIMEOUT 30

void Q_onAssert(char const Q_ROM * const Q_ROM_VAR file, int line){

}

void QF_onStartup(void)
{
    BSP_clockInit();
}

void QK_onIdle(void){}
void QF_onCleanup(void) {}

void QF_onClockTick(void)
{
    QF_TICK((void *) 0);
    /*BSP_onKeyboard();*/
}

enum MyAOSignals
{
    TIMEOUT_SIG = Q_USER_SIG,
    UP_SIG,
    DOWN_SIG,
    ARM_SIG,
    MAX_SIG
};


/* @(/1/0) .................................................................*/
typedef struct MyAOTag {
/* protected: */
    QActive super;

/* private: */
    QTimeEvt TimeEvt;

/* public: */
    uint8_t timeout;

/* private: */
    uint8_t code;
    uint8_t defuse;
} MyAO;

/* protected: */
static QState MyAO_initial(MyAO * const me, QEvt const * const e);
static QState MyAO_SET(MyAO * const me, QEvt const * const e);
static QState MyAO_Timing(MyAO * const me, QEvt const * const e);

/* @(/1/0) .................................................................*/
/* @(/1/0/4) ...............................................................*/
/* @(/1/0/4/0) */
static QState MyAO_initial(MyAO * const me, QEvt const * const e) {
    me->timeout = INIT_TIMEOUT;
    me->defuse = INIT_DEFUSE;
    QTimeEvt_postEvery(&me->TimeEvt, (QActive *)me, BSP_TICKS_PER_SEC/2);
    return Q_TRAN(&MyAO_SET);
}
/* @(/1/0/4/1) .............................................................*/
static QState MyAO_SET(MyAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/0/4/1/0) */
        case ARM_SIG: {
            me->code = 0;
            status_ = Q_TRAN(&MyAO_Timing);
            break;
        }
        /* @(/1/0/4/1/1) */
        case DOWN_SIG: {
            /* @(/1/0/4/1/1/0) */
            if (me->timeout > 1) {
                --me->timeout;
                BSP_display_timeout();
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /* @(/1/0/4/1/2) */
        case UP_SIG: {
            /* @(/1/0/4/1/2/0) */
            if (me->timeout < 60) {
                ++me->timeout;
                BSP_display_timeout();
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/* @(/1/0/4/2) .............................................................*/
static QState MyAO_Timing(MyAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/0/4/2/0) */
        case ARM_SIG: {
            /* @(/1/0/4/2/0/0) */
            if (me->code == me->defuse) {
                status_ = Q_TRAN(&MyAO_SET);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /* @(/1/0/4/2/1) */
        case UP_SIG: {
            me->code <<= 1;
            me->code |= 1;
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/0/4/2/2) */
        case DOWN_SIG: {
            me->code <<= 1;
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/0/4/2/3) */
        case TIMEOUT_SIG: {
            --me->timeout;
            BSP_display_timeout();
            /* @(/1/0/4/2/3/0) */
            if (me->timeout == 0) {
                BSP_Boom();
                status_ = Q_HANDLED();
            }
            /* @(/1/0/4/2/3/1) */
            else {
                status_ = Q_TRAN(&MyAO_Timing);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

static MyAO l_MyAO;
QActive *AOs_MyAO = &l_MyAO;

static void MyAO_ctor(void)
{
    MyAO *me = (MyAO *)AOs_MyAO;
    QActive_ctor(&me->super, (QStateHandler)&MyAO_initial);
    QTimeEvt_ctor(&me->TimeEvt, TIMEOUT_SIG);
}

void BSP_display_timeout(void)
{
    USART_printf(USART2, "%d", l_MyAO.timeout);
}

void BSP_Boom(void)
{
    USART_printf(USART2, "Boom");
}

void BSP_onKeyboard(void)
{
    uint8_t key;

    /*USART_printf(USART2, "Hellow");*/

    while(USART_GetFlagStatus(USART2, USART_FLAG_RXNE) != RESET);
    key = (uint8_t) USART_ReceiveData(USART2);

    switch(key)
    {
        case 'u':
        case 'U':
            QACTIVE_POST((QActive *)&l_MyAO,
                    Q_NEW(QEvt, UP_SIG), (void *)0);
            break;

        case 'd':
        case 'D':
            QACTIVE_POST((QActive *)&l_MyAO,
                    Q_NEW(QEvt, DOWN_SIG), (void *)0);
            break;

        case 'a':
        case 'A':
            QACTIVE_POST((QActive *)&l_MyAO,
                    Q_NEW(QEvt, ARM_SIG), (void *)0);
            break;
    }

}

int main(void)
{
    MyAO_ctor();
    BSP_init();
    QF_init();

    static QEvt const *myao_queueSto[10];
    QActive_start(AOs_MyAO,
            1, myao_queueSto, Q_DIM(myao_queueSto),
            (void *)0, 1024, (QEvt *)0);

    return QF_run();
}
